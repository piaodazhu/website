
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>ctypes --- Python 的外部函数库 &#8212; Python 3.7.9 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.7.9 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="并发执行" href="concurrency.html" />
    <link rel="prev" title="errno --- 标准 errno 系统符号" href="errno.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/ctypes.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="并发执行"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- 标准 errno 系统符号"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.7.9 Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">通用操作系统服务</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> --- Python 的外部函数库<a class="headerlink" href="#module-ctypes" title="永久链接至标题">¶</a></h1>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>
<div class="section" id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2>ctypes 教程<a class="headerlink" href="#ctypes-tutorial" title="永久链接至标题">¶</a></h2>
<p>注意：在本教程中的示例代码使用 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 进行过测试，保证其正确运行。由于有些代码在Linux，Windows或Mac OS X下的表现不同，这些代码会在 doctest 中包含相关的指令注解。</p>
<p>注意：部分示例代码引用了 ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 类型。在 <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code> 的平台上此类型是 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 的一个别名。所以，在程序输出 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 而不是你期望的 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 时不必感到迷惑 --- 它们实际上是同一种类型。</p>
<div class="section" id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3>载入动态连接库<a class="headerlink" href="#loading-dynamic-link-libraries" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 导出了 <em>cdll</em> 对象，在 Windows 系统中还导出了 <em>windll</em> 和 <em>oledll</em> 对象用于载入动态连接库。</p>
<p>通过操作这些对象的属性，你可以载入外部的动态链接库。<em>cdll</em> 载入按标准的 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用协议导出的函数，而 <em>windll</em> 导入的库按 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用协议调用其中的函数。 <em>oledll</em> 也按 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用协议调用其中的函数，并假定该函数返回的是 Windows <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 错误代码，并当函数调用失败时，自动根据该代码甩出一个 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>原来在 Windows 下甩出的异常类型 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> 现在是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的一个别名。</p>
</div>
<p>这是一些 Windows 下的例子。注意：<code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 是微软 C 标准库，包含了大部分 C 标准函数，这些函数都是以 cdecl 调用协议进行调用的。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>  
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>      
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>      
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows会自动添加通常的 <code class="docutils literal notranslate"><span class="pre">.dll</span></code> 文件扩展名。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>通过 <code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code> 调用的标准 C 函数，可能会导致调用一个过时的，与当前 Python 所不兼容的函数。因此，请尽量使用标准的 Python 函数，而不要使用 <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 模块。</p>
</div>
<p>在 Linux 下，必须使用 <em>包含</em> 文件扩展名的文件名来导入共享库。因此不能简单使用对象属性的方式来导入库。因此，你可以使用方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code>，或构造 CDLL 对象来导入库。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>       
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                           
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>操作导入的动态链接库中的函数<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="永久链接至标题">¶</a></h3>
<p>通过操作dll对象的属性来操作这些函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>     
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意：Win32系统的动态库，比如 <code class="docutils literal notranslate"><span class="pre">kernel32</span></code> 和 <code class="docutils literal notranslate"><span class="pre">user32</span></code>，通常会同时导出同一个函数的 ANSI 版本和 UNICODE 版本。UNICODE 版本通常会在名字最后以 <code class="docutils literal notranslate"><span class="pre">W</span></code> 结尾，而 ANSI 版本的则以 <code class="docutils literal notranslate"><span class="pre">A</span></code> 结尾。 win32的 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 函数会根据一个模块名返回一个 <em>模块句柄</em>，该函数暨同时包含这样的两个版本的原型函数，并通过宏 UNICODE 是否定义，来决定宏 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 导出的是哪个具体函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p><em>windll</em> 不会通过这样的魔法手段来帮你决定选择哪一种函数，你必须显式的调用 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> 或 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code>，并分别使用字节对象或字符串对象作参数。</p>
<p>有时候，dlls的导出的函数名不符合 Python 的标识符规范，比如 <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>。此时，你必须使用 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 方法来获得该函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows 下，有些 dll 导出的函数没有函数名，而是通过其顺序号调用。对此类函数，你也可以通过 dll 对象的数值索引来操作这些函数。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions">
<span id="ctypes-calling-functions"></span><h3>调用函数<a class="headerlink" href="#calling-functions" title="永久链接至标题">¶</a></h3>
<p>你可以貌似是调用其它 Python 函数那样直接调用这些函数。在这个例子中，我们调用了 <code class="docutils literal notranslate"><span class="pre">time()</span></code> 函数，该函数返回一个系统时间戳（从 Unix 时间起点到现在的秒数），而``GetModuleHandleA()`` 函数返回一个 win32 模块句柄。</p>
<p>此函数中调用的两个函数都使用了空指针（用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为空指针）:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>  
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用方式调用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 约定的函数，则会甩出一个异常 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。反之亦然。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>你必须阅读这些库的头文件或说明文档来确定它们的正确的调用协议。</p>
<p>在Windows中，<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 使用 win32 结构化异常处理来防止由于在调用函数时使用非法参数导致的程序崩溃。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>然而，总有许多办法，通过调用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 使得 Python 程序崩溃。因此，你必须小心使用。 <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> 模块可以用于帮助诊断程序崩溃的原因。（比如由于错误的C库函数调用导致的段错误）。</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code>，整型，字节对象和（UNICODE）字符串是仅有的可以直接作为函数参数使用的四种Python本地数据类型。<cite>None`</cite> 作为C的空指针 (<code class="docutils literal notranslate"><span class="pre">NULL</span></code>)，字节和字符串类型作为一个指向其保存数据的内存块指针 （<code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code>)。Python 的整型则作为平台默认的C的 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 类型，他们的数值被截断以适应C类型的整型长度。</p>
<p>在我们开始调用函数前，我们必须先了解作为函数参数的 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型。</p>
</div>
<div class="section" id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3>基础数据类型<a class="headerlink" href="#fundamental-data-types" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 定义了一些和C兼容的基本数据类型：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 46%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ctypes 类型</p></th>
<th class="head"><p>C 类型</p></th>
<th class="head"><p>Python 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code></p></td>
<td><p>bool (1)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p>单字符字节对象</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code></p></td>
<td><p>单字符字符串</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">short</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">__int64</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int64</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></p></td>
<td><p>整型</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>浮点数</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p>浮点数</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code></p></td>
<td><p>浮点数</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> (以 NUL 结尾)</p></td>
<td><p>字节串对象或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> (以 NUL 结尾)</p></td>
<td><p>字符串或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code></p></td>
<td><p>int 或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p>构造函数接受任何具有真值的对象。</p></li>
</ol>
<p>所有这些类型都可以通过使用正确类型和值的可选初始值调用它们来创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于这些类型是可变的，它们的值也可以在以后更改:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当给指针类型的对象 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a> 和 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 等赋值时，将改变它们所指向的 <em>内存地址</em>，而 <em>不是</em> 它们所指向的内存区域的 <em>内容</em> (这是理所当然的，因为 Python 的 bytes 对象是不可变的):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># the memory location has changed</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># first object is unchanged</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>但你要注意不能将它们传递给会改变指针所指内存的函数。如果你需要可改变的内存块，ctypes 提供了 <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 函数，它提供多种方式创建这种内存块。当前的内存块内容可以通过 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 属性存取，如果你希望将它作为NUL结束的字符串，请使用 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># create a 3 byte buffer, initialized to NUL bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># create a buffer containing a NUL terminated string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># create a 10 byte buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 函数替代以前的ctypes版本中的 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code> 函数 (仍然可当作别名使用)和 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_string()</span></code> 函数。<a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> 函数创建包含 unicode 字符的可变内存块，与之对应的C语言类型是 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>。</p>
</div>
<div class="section" id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3>调用函数，继续<a class="headerlink" href="#calling-functions-continued" title="永久链接至标题">¶</a></h3>
<p>注意 printf 将打印到真正标准输出设备，而*不是* <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>，因此这些实例只能在控制台提示符下工作，而不能在 <em>IDLE</em> 或 <em>PythonWin</em> 中运行。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正如前面所提到过的，除了整数、字符串以及字节串之外，所有的 Python 类型都必须使用它们对应的 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型包装，才能够被正确地转换为所需的C语言类型。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3>使用自定义的数据类型调用函数<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="永久链接至标题">¶</a></h3>
<p>你也可以通过自定义  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 参数转换方式来允许自定义类型作为参数。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会寻找 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性并使用它作为函数参数。当然，它必须是数字、字符串或者二进制字符串:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你不想把实例的数据存储到 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性。可以通过定义 <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> 函数计算出这个属性。</p>
</div>
<div class="section" id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3>指定必选参数的类型(函数原型)<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="永久链接至标题">¶</a></h3>
<p>可以通过设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 属性的方法指定从 DLL 中导出函数的必选参数类型。</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 必须是一个 C 数据类型的序列 (这里的 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 可能不是个好例子，因为它是变长参数，而且每个参数的类型依赖于格式化字符串，不过尝试这个功能也很方便):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>指定数据类型可以防止不合理的参数传递(就像C函数的函数签名)，并且会自动尝试将参数转换为需要的类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果你想通过自定义类型传递参数给函数，必须实现 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 类方法，才能够将此自定义类型用于 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 序列。<code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 类方法接受一个 Python 对象作为函数输入，它应该进行类型检查或者其他必要的操作以保证接收到的对象是合法的，然后返回这个对象，或者它的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性，或者其他你想要传递给 C 函数的参数。这里也一样，返回的结果必须是整型、字符串、二进制字符串、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型，或者一个具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性的对象。</p>
</div>
<div class="section" id="return-types">
<span id="ctypes-return-types"></span><h3>返回类型<a class="headerlink" href="#return-types" title="永久链接至标题">¶</a></h3>
<p>默认情况下都会假定函数返回C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 类型。其他返回类型可以通过设置函数对象的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性来指定。</p>
<p>这是个更高级的例子，它调用了 <code class="docutils literal notranslate"><span class="pre">strchr</span></code> 函数，这个函数接收一个字符串指针以及一个字符作为参数，返回另一个字符串指针。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>  
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果希望避免上述的 <code class="docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code> 调用，可以设置  <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>  属性，第二个参数就会将单字符的 Python 二进制字符对象转换为 C 字符:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果外部函数返回了一个整数，你也可以使用要给可调用的 Python 对象（比如函数或者类）作为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性的值。将会以 C 函数返回的 <em>整数</em> 对象作为参数调用这个可调用对象，执行后的结果作为最终函数返回值。这在错误返回值校验和自动抛出异常等方面比较有用。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WinError</span></code> 函数可以调用 Windows 的  <code class="docutils literal notranslate"><span class="pre">FormatMessage()</span></code> API 获取错误码的字符串说明，然后 <em>返回</em> 一个异常。 <code class="docutils literal notranslate"><span class="pre">WinError</span></code> 接收一个可选的错误码作为参数，如果没有的话，它将调用  <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 获取错误码。</p>
<p>请注意，使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code>  属性可以实现更强大的错误检查手段；详情请见参考手册。</p>
</div>
<div class="section" id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3>传递指针(或者传递引用)<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="永久链接至标题">¶</a></h3>
<p>有时候 C 函数接口可能由于要往某个地址写入值，或者数据太大不适合作为值传递，从而希望接收一个 <em>指针</em> 作为数据参数类型。这和 <em>传递参数引用</em> 类似。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 暴露了 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 函数用于通过引用传递参数，使用 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数也能达到同样的效果，只不过 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 需要更多步骤，因为它要先构造一个真实指针对象。所以在 Python 代码本身不需要使用这个指针对象的情况下，使用 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 效率更高。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3>结构体和联合<a class="headerlink" href="#structures-and-unions" title="永久链接至标题">¶</a></h3>
<p>结构体和联合必须继承自 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块中的 <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> 和 <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a> 。子类必须定义 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 属性。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 是一个二元组列表，二元组中包含 <em>field name</em> 和 <em>field type</em> 。</p>
<p>type 字段必须是一个 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型，比如  <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>，或者其他 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型: 结构体、联合、数组、指针。</p>
<p>这是一个简单的 POINT 结构体，它包含名称为 <em>x</em> 和 <em>y</em> 的两个变量，还展示了如何通过构造函数初始化结构体。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>当然，你可以构造更复杂的结构体。一个结构体可以通过设置 type 字段包含其他结构体或者自身。</p>
<p>这是以一个 RECT 结构体，他包含了两个 POINT ，分别叫 <em>upperleft</em> 和 <em>lowerright</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>嵌套结构体可以通过几种方式构造初始化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>可以通过 <em>类</em> 获取字段 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> ，它能提供很多有用的调试信息。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning" id="ctypes-structureunion-alignment-byte-order">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 不支持带位域的结构体、联合以值的方式传给函数。这可能在 32 位 x86 平台上可以正常工作，但是对于一般情况，这种行为是未定义的。带位域的结构体、联合应该总是通过指针传递给函数。</p>
</div>
</div>
<div class="section" id="structure-union-alignment-and-byte-order">
<h3>结构体/联合 字段对齐及字节顺序<a class="headerlink" href="#structure-union-alignment-and-byte-order" title="永久链接至标题">¶</a></h3>
<p>默认情况下，结构体和联合的字段与C的字节对齐是一样的。也可以在定义子类的时候指定类的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 属性来覆盖这种行为。它必须设置为一个正整数，表示字段的最大对齐字节。这和 MSVC 中的 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></code> 功能一样。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中的结构体和联合使用的是本地字节序。要使用非本地字节序，可以使用 <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code>, and <code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code> 作为基类。这些类不能包含指针字段。</p>
</div>
<div class="section" id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3>结构体和联合中的位域<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="永久链接至标题">¶</a></h3>
<p>结构体和联合中是可以包含位域字段的。位域只能用于整型字段，位长度通过 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 中的第三个参数指定:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="arrays">
<span id="ctypes-arrays"></span><h3>数组<a class="headerlink" href="#arrays" title="永久链接至标题">¶</a></h3>
<p>数组是一个序列，包含指定个数元素，且必须类型相同。</p>
<p>创建数组类型的推荐方式是使用一个类型乘以一个正数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>下面是一个构造的数据案例，结构体中包含了4个 POINT 和一些其他东西。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>和平常一样，通过调用它创建实例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>以上代码会打印几行 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code> ，因为数组内容被初始化为 0.</p>
<p>也能通过指定正确类型的数据来初始化:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="pointers">
<span id="ctypes-pointers"></span><h3>指针<a class="headerlink" href="#pointers" title="永久链接至标题">¶</a></h3>
<p>指针可以通过 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中的 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数进行创建:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>指针实例拥有 <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> 属性，它存储了指针指向的真实对象，如上面的 <code class="docutils literal notranslate"><span class="pre">i</span></code> 对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 并没有 OOR （返回原始对象）, 每次访问这个属性时都会构造返回一个新的相同对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>将这个指针的 contents 属性赋值为另一个 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 实例将会导致该指针指向该实例的内存地址:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>指针对象也可以通过整数下标进行访问:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>通过整数下标赋值可以改变内容。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用0以外的索引也是合法的，但是你必须确保这么做的后果，就像 C 语言中: 你可以访问或者修改任意内存内容。通常只会在函数接收指针是才会使用这种特性，而且你 <em>知道</em> 这个指针指向的是一个数组而不是单个值。</p>
<p>内部细节,  <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数不只是创建了一个指针实例，它首先创建了一个指针 <em>类型</em> 。这是通过调用 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 函数实现的，它接收  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型为参数，返回一个新的类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>无参调用指针类型可以创建一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针的布尔值是 <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>解引用指针的时候， <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会帮你检测是否指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (但是解引用无效的 非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针仍会导致 Python 崩溃):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="type-conversions">
<span id="ctypes-type-conversions"></span><h3>类型强制转换<a class="headerlink" href="#type-conversions" title="永久链接至标题">¶</a></h3>
<p>通常情况下, ctypes 具有严格的类型检查。这代表着, 如果在函数 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 中或者结构体定义成员中有 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 类型，只有相同类型的实例才会被接受。 也有一些例外。比如，你可以传递兼容的数组实例给指针类型。所以，对于  <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> ，ctypes 也可以接受 c_int 类型的数组:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>另外，如果一个函数 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 列表中的参数显式的定义为指针类型(如 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> )，指针所指向的 类型 (这个例子中是 <code class="docutils literal notranslate"><span class="pre">c_int</span></code> )也可以传递给函数。ctypes 会自动调用对应的 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 转换。</p>
<p>可以给指针内容赋值为 None 将其设置为 <code class="docutils literal notranslate"><span class="pre">Null</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有时候你拥有一个不完整的类型。在 C 中，你可以将一个类型强制转换为另一个。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>  中的 a <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数提供了相同的功能。上面的结构体  <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的 <code class="docutils literal notranslate"><span class="pre">value</span></code> 字段接收  <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 指针或者 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>  数组，但是不能接受其他类型的实例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种情况下, 需要手动使用 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数。</p>
<p><a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数可以将一个指针实例强制转换为另一种 ctypes 类型。 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a>  接收两个参数，一个 ctypes 指针对象或者可以被转换为指针的其他类型对象，和一个 ctypes 指针类型。返回第二个类型的一个实例，该返回实例和第一个参数指向同一片内存空间:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>所以  <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 可以用来给结构体 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的 <code class="docutils literal notranslate"><span class="pre">values</span></code> 字段赋值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3>不完整类型<a class="headerlink" href="#incomplete-types" title="永久链接至标题">¶</a></h3>
<p><em>不完整类型</em> 即还没有定义成员的结构体、联合或者数组。在 C 中，它们通常用于前置声明，然后在后面定义:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>直接翻译成 ctypes 的代码如下，但是这行不通:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>因为新的 <code class="docutils literal notranslate"><span class="pre">cell</span> <span class="pre">类</span></code> 在 class 语句结束之前还没有完成定义。在  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中，我们可以先定义 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 类，在 class 语句结束之后再设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 属性:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>让我们试试。我们定义两个 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 实例，让它们互相指向对方，然后通过指针链式访问几次:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="callback-functions">
<span id="ctypes-callback-functions"></span><h3>回调函数<a class="headerlink" href="#callback-functions" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 允许创建一个指向 Python 可调用对象的 C 函数。它们有时候被称为 <em>回调函数</em> 。</p>
<p>首先，你必须为回调函数创建一个类，这个类知道调用约定，包括返回值类型以及函数接收的参数类型及个数。</p>
<p><a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 工厂函数使用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用约定创建回调函数类型。在 Windows 上， <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> 工厂函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定为回调函数创建类型。</p>
<p>这些工厂函数都是用返回值类型作为第一个参数，回掉函数的参数类型作为剩余参数。</p>
<p>这里展示一个使用 C 标准库函数  <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code>  的例子，它使用一个回掉函数对数据进行排序。 <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> 将用来给整数数组排序:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code> 必须接收的参数，一个指向待排序数据的指针，元素个数，每个元素的大小，以及一个指向排序函数的指针，即回调函数。然后回调函数接收两个元素的指针，如果第一个元素小于第二个，则返回一个负整数，如果相等则返回0，否则返回一个正整数。</p>
<p>所以，我们的回调函数要接收两个整数指针，返回一个整数。首先我们创建回调函数的 <code class="docutils literal notranslate"><span class="pre">类型</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>首先，这是一个简单的回调，它会显示传入的值:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>结果:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>  
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>现在我们可以比较两个元素并返回有用的结果了:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> 
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>我们可以轻易地验证，现在数组是有序的了:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这些工厂函数可以当作装饰器工厂，所以可以这样写:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>请确保你维持 <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 对象的引用与它们在 C 代码中的使用期一样长。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 不会确保这一点，而如果你不这样做，它们可能会被垃圾回收，导致你的程序在执行回调函数时发生崩溃。</p>
<p>注意，如果回调函数在Python之外的另外一个线程使用(比如，外部代码调用这个回调函数)， ctypes 会在每一次调用上创建一个虚拟 Python 线程。这个行为在大多数情况下是合理的，但也意味着如果有数据使用 <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> 方式存储，将无法访问，就算它们是在同一个 C 线程中调用的 。</p>
</div>
</div>
<div class="section" id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3>访问 dll 中导出的值<a class="headerlink" href="#accessing-values-exported-from-dlls" title="永久链接至标题">¶</a></h3>
<p>一些动态链接库不仅仅导出函数，也会导出变量。一个例子就是 Python 库本身的 <a class="reference internal" href="../c-api/init.html#c.Py_OptimizeFlag" title="Py_OptimizeFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_OptimizeFlag</span></code></a> ，根据启动选项 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 、 <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> 的不同，它是值可能为 0、1、2 的整型。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 可以通过  <code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code> 类方法访问这类变量 。 <em>pythonapi</em> 是用于访问 Python C 接口的预定义符号:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">opt_flag</span><span class="p">)</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>如果解释器使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项启动，这个例子会打印 <code class="docutils literal notranslate"><span class="pre">c_long(1)</span></code> ， 如果使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> 启动，则会打印 <code class="docutils literal notranslate"><span class="pre">c_long(2)</span></code> 。</p>
<p>一个扩展例子,  同时也展示了使用指针访问 Python 导出的 <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> 指针对象。</p>
<p>对文档中这个值的解释说明</p>
<blockquote>
<div><p>该指针被初始化为指向 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code> 数组，以 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或者 0 作为结束标记。当一个冻结模块被导入，首先要在这个表中搜索。第三方库可以以此来提供动态创建的冻结模块集合。</p>
</div></blockquote>
<p>这足以证明修改这个指针是很有用的。为了让实例大小不至于太长，这里只展示如何使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 读取这个表:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>我们定义了  <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code>  数据类型，接着就可以获取这张表的指针了:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;PyImport_FrozenModules&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal notranslate"><span class="pre">table</span></code> 是指向 <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code> 数组的 <code class="docutils literal notranslate"><span class="pre">指针</span></code> ，我们可以遍历它，只不过需要自己判断循环是否结束，因为指针本身并不包含长度。它早晚会因为访问到野指针或者什么的把自己搞崩溃，所以我们最好在遇到  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 后就让它退出循环:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">__hello__ 161</span>
<span class="go">__phello__ -161</span>
<span class="go">__phello__.spam 161</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Python 的冻结模块和冻结包(由负 <code class="docutils literal notranslate"><span class="pre">size</span></code> 成员表示)并不是广为人知的事情，它们仅仅用于实验。例如，可以使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code> 尝试一下这个功能。</p>
</div>
<div class="section" id="surprises">
<span id="ctypes-surprises"></span><h3>意外<a class="headerlink" href="#surprises" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 也有自己的边界，有时候会发生一些意想不到的事情。</p>
<p>比如下面的例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>嗯。我们预想应该打印 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code> 。但是为什么呢? 这是 <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> 这行代码展开后的步骤:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>注意 <code class="docutils literal notranslate"><span class="pre">temp0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">temp1</span></code> 对象始终引用了对象 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 的内容。然后执行 <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> 会把 <code class="docutils literal notranslate"><span class="pre">temp0</span></code> 的内容拷贝到 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 的空间。这也改变了  <code class="docutils literal notranslate"><span class="pre">temp1</span></code> 的内容。最终导致赋值语句 <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code> 没有产生预想的效果。</p>
<p>记住，访问被包含在结构体、联合、数组中的对象并不会将其 <em>复制</em> 出来，而是得到了一个代理对象，它是对根对象的内部内容进行了一层包装。</p>
<p>另一个和预期可能有偏差的例子是这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">b&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>使用  <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>  实例化的对象只能将其值设置为 bytes 或者整数。</p>
</div>
<p>为什么这里打印了 <code class="docutils literal notranslate"><span class="pre">False</span></code> ？ ctypes 实例是一些内存块加上一些用于访问这些内存块的 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> 组成。将 Python 对象存储在内存块并不会存储对象本身，而是存储了对象的 <code class="docutils literal notranslate"><span class="pre">内容</span></code> 。每次访问对象的内容都会构造一个新的 Python 对象。</p>
</div>
<div class="section" id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3>变长数据类型<a class="headerlink" href="#variable-sized-data-types" title="永久链接至标题">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 对变长数组和结构体提供了一些支持 。</p>
<p>The <a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> function can be used to resize the memory buffer of an
existing ctypes object.  The function takes the object as first argument, and
the requested size in bytes as the second argument.  The memory block cannot be
made smaller than the natural memory block specified by the objects type, a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if this is tried:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这非常好，但是要怎么访问数组中额外的元素呢？因为数组类型已经定义包含4个元素，women访问新增元素会产生以下错误:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>使用  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 访问变长数据类型的一个可行方法是利用 Python 的动态特性，根据具体情况，在知道这个数据的大小后，(重新)指定这个数据的类型。</p>
</div>
</div>
<div class="section" id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2>ctypes 参考手册<a class="headerlink" href="#ctypes-reference" title="永久链接至标题">¶</a></h2>
<div class="section" id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3>寻找动态链接库<a class="headerlink" href="#finding-shared-libraries" title="永久链接至标题">¶</a></h3>
<p>在编译型语言中，动态链接库会在编译、链接或者程序运行时访问。</p>
<p>The purpose of the <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> function is to locate a library in a way
similar to what the compiler or runtime loader does (on platforms with several
versions of a shared library the most recent should be loaded), while the ctypes
library loaders act like when a program is run, and call the runtime loader
directly.</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> 模块提供了一个函数，可以帮助确定需要加载的库。</p>
<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.util.</code><code class="sig-name descname">find_library</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span></dt>
<dd><p>尝试寻找一个库然后返回其路径名， <em>name</em> 是库名称, 且去除了 <em>lib</em> 等前缀和 <code class="docutils literal notranslate"><span class="pre">.so</span></code> 、 <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 、版本号等后缀(这是 posix 连接器 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code> 选项使用的格式)。如果没有找到对应的库，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</dd></dl>

<p>确切的功能取决于系统。</p>
<p>在 Linux 上， <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 会尝试运行外部程序(<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">ld</span></code>) 来寻找库文件。返回库文件的文件名。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>在Linux 上，如果其他方式找不到的话，会使用环境变量 <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> 搜索动态链接库。</p>
</div>
<p>这是一些例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 OS X 上， <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 会尝试几种预定义的命名方案和路径来查找库，如果成功，则返回完整的路径名:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>在 Windows 上，  <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 在系统路径中搜索，然后返回全路径，但是如果没有预定义的命名方案， <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code> 调用会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<p>使用  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 包装动态链接库，更好的方式 <em>可能</em> 是在开发的时候就确定名称，然后硬编码到包装模块中去，而不是在运行时使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 寻找库。</p>
</div>
<div class="section" id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3>加载动态链接库<a class="headerlink" href="#loading-shared-libraries" title="永久链接至标题">¶</a></h3>
<p>有很多方式可以将动态链接库加载到 Python 进程。其中之一是实例化以下类的其中一个:</p>
<dl class="class">
<dt id="ctypes.CDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">CDLL</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">mode=DEFAULT_MODE</em>, <em class="sig-param">handle=None</em>, <em class="sig-param">use_errno=False</em>, <em class="sig-param">use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="永久链接至目标">¶</a></dt>
<dd><p>此类的实例即已加载的动态链接库。库中的函数使用标准 C 调用约定，并假定返回 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.OleDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">OleDLL</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">mode=DEFAULT_MODE</em>, <em class="sig-param">handle=None</em>, <em class="sig-param">use_errno=False</em>, <em class="sig-param">use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="永久链接至目标">¶</a></dt>
<dd><p>仅 Windows : 此类的实例即加载好的动态链接库，其中的函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定，并且假定返回 windows 指定的 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 返回码。 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 的值包含的信息说明函数调用成功还是失败，以及额外错误码。 如果返回值表示失败，会自动抛出 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>以前是引发 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.WinDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">WinDLL</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">mode=DEFAULT_MODE</em>, <em class="sig-param">handle=None</em>, <em class="sig-param">use_errno=False</em>, <em class="sig-param">use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="永久链接至目标">¶</a></dt>
<dd><p>仅 Windows: 此类的实例即加载好的动态链接库，其中的函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定，并假定默认返回 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 。</p>
<p>在 Windows CE 上，只能使用 stdcall 调用约定，为了方便， <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 和 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 在这个平台上都使用标准调用约定。</p>
</dd></dl>

<p>调用动态库导出的函数之前，Python会释放 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> ，并在调用后重新获取。</p>
<dl class="class">
<dt id="ctypes.PyDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">PyDLL</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">mode=DEFAULT_MODE</em>, <em class="sig-param">handle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="永久链接至目标">¶</a></dt>
<dd><p>这个类实例的行为与 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 类似，只不过 <em>不会</em> 在调用函数的时候释放 GIL 锁，且调用结束后会检查 Python 错误码。 如果错误码被设置，会抛出一个 Python 异常。</p>
<p>所以，它只在直接调用 Python C 接口函数的时候有用。</p>
</dd></dl>

<p>通过使用至少一个参数（共享库的路径名）调用它们，可以实例化所有这些类。也可以传入一个已加载的动态链接库作为 <code class="docutils literal notranslate"><span class="pre">handler</span></code> 参数，其他情况会调用系统底层的  <code class="docutils literal notranslate"><span class="pre">dlopen</span></code> 或 <code class="docutils literal notranslate"><span class="pre">LoadLibrary</span></code> 函数将库加载到进程，并获取其句柄。</p>
<p><em>mode</em> 可以指定库加载方式。详情请参见  <em class="manpage">dlopen(3)</em> 手册页。 在 Windows 上， 会忽略 <em>mode</em> ，在 posix 系统上， 总是会加上 RTLD_NOW ，且无法配置。</p>
<p><em>use_errno</em> 参数如果设置为 true，可以启用ctypes的机制，通过一种安全的方法获取系统的  <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 错误码。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 维护了一个线程局部变量，它是系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 的一份拷贝；如果调用了使用 <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> 创建的外部函数， <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 的值会与 ctypes 自己拷贝的那一份进行交换，函数执行完后立即再交换一次。</p>
<p>The function <a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> returns the value of the ctypes private
copy, and the function <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> changes the ctypes private copy
to a new value and returns the former value.</p>
<p><em>use_last_error</em>  参数如果设置为 true，可以在 Windows 上启用相同的策略，它是通过 Windows API 函数 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a>  和 <code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code> 管理的。 <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> 和 <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a> 可用于获取和设置 ctypes 自己维护的 windows 错误码拷贝。</p>
<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">RTLD_GLOBAL</code></dt>
<dd><p>用于 <em>mode</em> 参数的标识值。在此标识不可用的系统上，它被定义为整数0。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">RTLD_LOCAL</code></dt>
<dd><p>Flag to use as <em>mode</em> parameter.  On platforms where this is not available, it
is the same as <em>RTLD_GLOBAL</em>.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">DEFAULT_MODE</code></dt>
<dd><p>加载动态链接库的默认模式。在 OSX 10.3 上，它是 <em>RTLD_GLOBAL</em> ，其余系统上是 <em>RTLD_LOCAL</em> 。</p>
</dd></dl>

<p>这些类的实例没有共用方法。动态链接库的导出函数可以通过属性或者数组下标的方式访问。注意，通过属性的方式访问会缓存这个函数，因而每次访问它时返回的都是同一个对象。另一方面，通过数组下标访问，每次都会返回一个新的对象:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># On Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>还有下面这些属性可用，他们的名称以下划线开头，以避免和导出函数重名:</p>
<dl class="attribute">
<dt id="ctypes.PyDLL._handle">
<code class="sig-prename descclassname">PyDLL.</code><code class="sig-name descname">_handle</code><a class="headerlink" href="#ctypes.PyDLL._handle" title="永久链接至目标">¶</a></dt>
<dd><p>用于访问库的系统句柄。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.PyDLL._name">
<code class="sig-prename descclassname">PyDLL.</code><code class="sig-name descname">_name</code><a class="headerlink" href="#ctypes.PyDLL._name" title="永久链接至目标">¶</a></dt>
<dd><p>传入构造函数的库名称。</p>
</dd></dl>

<p>共享库也可以通用使用一个预制对象来加载，这种对象是 <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a> 类的实例，具体做法或是通过调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> 方法，或是通过将库作为加载实例的属性来提取。</p>
<dl class="class">
<dt id="ctypes.LibraryLoader">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">LibraryLoader</code><span class="sig-paren">(</span><em class="sig-param">dlltype</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="永久链接至目标">¶</a></dt>
<dd><p>加载共享库的类。 <em>dlltype</em> 应当为 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 或 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 类型之一。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 具有特殊的行为：它允许通过将一个共享库作为库加载器实例的属性进行访问来加载它。 加载结果将被缓存，因此重复的属性访问每次都会返回相同的库。</p>
<dl class="method">
<dt id="ctypes.LibraryLoader.LoadLibrary">
<code class="sig-name descname">LoadLibrary</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="永久链接至目标">¶</a></dt>
<dd><p>加载一个共享库到进程中并将其返回。 此方法总是返回一个新的库实例。</p>
</dd></dl>

</dd></dl>

<p>可用的预制库加载器有如下这些:</p>
<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">cdll</code></dt>
<dd><p>创建 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 实例。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">windll</code></dt>
<dd><p>仅Windows中: 创建 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 实例.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">oledll</code></dt>
<dd><p>仅Windows中: 创建 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 实例。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">pydll</code></dt>
<dd><p>创建 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> 实例。</p>
</dd></dl>

<p>要直接访问 C Python api，可以使用一个现成的 Python 共享库对象:</p>
<dl class="data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">pythonapi</code></dt>
<dd><p>一个 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> 的实例，它将 Python C API 函数作为属性公开。 请注意所有这些函数都应返回 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>，当然这也不是绝对的，因此你必须分配正确的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性以使用这些函数。</p>
</dd></dl>

</div>
<div class="section" id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3>外部函数<a class="headerlink" href="#foreign-functions" title="永久链接至标题">¶</a></h3>
<p>正如之前小节的说明，外部函数可作为被加载共享库的属性来访问。 用此方式创建的函数对象默认接受任意数量的参数，接受任意 ctypes 数据实例作为参数，并且返回库加载器所指定的默认结果类型。 它们是一个私有类的实例:</p>
<dl class="class">
<dt id="ctypes._FuncPtr">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_FuncPtr</code><a class="headerlink" href="#ctypes._FuncPtr" title="永久链接至目标">¶</a></dt>
<dd><p>C 可调用外部函数的基类。</p>
<p>外部函数的实例也是兼容 C 的数据类型；它们代表 C 函数指针。</p>
<p>此行为可通过对外部函数对象的特殊属性赋值来自定义。</p>
<dl class="attribute">
<dt id="ctypes._FuncPtr.restype">
<code class="sig-name descname">restype</code><a class="headerlink" href="#ctypes._FuncPtr.restype" title="永久链接至目标">¶</a></dt>
<dd><p>赋值为一个 ctypes 类型来指定外部函数的结果类型。 使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 表示 <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span></code>，即不返回任何结果的函数。</p>
<p>赋值为一个不为 ctypes 类型的可调用 Python 对象也是可以的，在此情况下函数应返回 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>，该可调用对象将附带此整数被调用，以允许进一步的处理或错误检测。 这种用法已被弃用，为了更灵活的后续处理或错误检测请使用一个 ctypes 数据类型作为 <a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> 并将 <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> 属性赋值为一个可调用对象。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.argtypes">
<code class="sig-name descname">argtypes</code><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="永久链接至目标">¶</a></dt>
<dd><p>赋值为一个 ctypes 类型的元组来指定函数所接受的参数类型。 使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用规范的函数只能附带与此元组长度相同数量的参数进行调用；使用 C 调用规范的函数还可接受额外的未指明参数。</p>
<p>当外部函数被调用时，每个实际参数都会被传给 <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中条目的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 类方法，此方法允许将实际参数适配为此外部函数所接受的对象。 例如，<a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中的 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 条目将使用 ctypes 约定规则把作为参数传入的字符串转换为字节串对象。</p>
<p>新增：现在可以将不是 ctypes 类型的条目放入 argtypes，但每个条目都必须具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 方法用于返回可作为参数的值（整数、字符串、ctypes 实例）。 这样就允许定义可将自定义对象适配为函数形参的适配器。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.errcheck">
<code class="sig-name descname">errcheck</code><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="永久链接至目标">¶</a></dt>
<dd><p>将一个 Python 函数或其他可调用对象赋值给此属性。 该可调用对象将附带三个及以上的参数被调用。</p>
<dl class="function">
<dt>
<code class="sig-name descname">callable</code><span class="sig-paren">(</span><em class="sig-param">result</em>, <em class="sig-param">func</em>, <em class="sig-param">arguments</em><span class="sig-paren">)</span></dt>
<dd><p><em>result</em> 是外部函数返回的结果，由 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性指明。</p>
<p><em>func</em> 是外部函数对象本身，这样就允许重新使用相同的可调用对象来对多个函数进行检查或后续处理。</p>
<p><em>arguments</em> 是一个包含最初传递给函数调用的形参的元组，这样就允许对所用参数的行为进行特别处理。</p>
</dd></dl>

<p>此函数所返回的对象将会由外部函数调用返回，但它还可以在外部函数调用失败时检查结果并引发异常。</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ctypes.ArgumentError">
<em class="property">exception </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">ArgumentError</code><a class="headerlink" href="#ctypes.ArgumentError" title="永久链接至目标">¶</a></dt>
<dd><p>此异常会在外部函数无法对某个传入参数执行转换时被引发。</p>
</dd></dl>

</div>
<div class="section" id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3>函数原型<a class="headerlink" href="#function-prototypes" title="永久链接至标题">¶</a></h3>
<p>外部函数也可通过实例化函数原型来创建。 函数原型类似于 C 中的函数原型；它们在不定义具体实现的情况下描述了一个函数（返回类型、参数类型、调用约定）。 工厂函数必须使用函数所需要的结果类型和参数类型来调用，并可被用作装饰器工厂函数，在此情况下可以通过 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 语法应用于函数。 请参阅 <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">回调函数</span></a> 了解有关示例。</p>
<dl class="function">
<dt id="ctypes.CFUNCTYPE">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">CFUNCTYPE</code><span class="sig-paren">(</span><em class="sig-param">restype</em>, <em class="sig-param">*argtypes</em>, <em class="sig-param">use_errno=False</em>, <em class="sig-param">use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>The returned function prototype creates functions that use the standard C
calling convention.  The function will release the GIL during the call.  If
<em>use_errno</em> is set to true, the ctypes private copy of the system
<a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> variable is exchanged with the real <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> value before
and after the call; <em>use_last_error</em> does the same for the Windows error
code.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WINFUNCTYPE">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">WINFUNCTYPE</code><span class="sig-paren">(</span><em class="sig-param">restype</em>, <em class="sig-param">*argtypes</em>, <em class="sig-param">use_errno=False</em>, <em class="sig-param">use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: The returned function prototype creates functions that use the
<code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, except on Windows CE where
<a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> is the same as <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a>.  The function will
release the GIL during the call.  <em>use_errno</em> and <em>use_last_error</em> have the
same meaning as above.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.PYFUNCTYPE">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">PYFUNCTYPE</code><span class="sig-paren">(</span><em class="sig-param">restype</em>, <em class="sig-param">*argtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="永久链接至目标">¶</a></dt>
<dd><p>The returned function prototype creates functions that use the Python calling
convention.  The function will <em>not</em> release the GIL during the call.</p>
</dd></dl>

<p>Function prototypes created by these factory functions can be instantiated in
different ways, depending on the type and number of the parameters in the call:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a foreign function at the specified address which must be an integer.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param">callable</em><span class="sig-paren">)</span></dt>
<dd><p>Create a C callable function (a callback function) from a Python <em>callable</em>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param">func_spec</em><span class="optional">[</span>, <em class="sig-param">paramflags</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a foreign function exported by a shared library. <em>func_spec</em> must
be a 2-tuple <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code>. The first item is the name of
the exported function as string, or the ordinal of the exported function
as small integer.  The second item is the shared library instance.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param">vtbl_index</em>, <em class="sig-param">name</em><span class="optional">[</span>, <em class="sig-param">paramflags</em><span class="optional">[</span>, <em class="sig-param">iid</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a foreign function that will call a COM method. <em>vtbl_index</em> is
the index into the virtual function table, a small non-negative
integer. <em>name</em> is name of the COM method. <em>iid</em> is an optional pointer to
the interface identifier which is used in extended error reporting.</p>
<p>COM methods use a special calling convention: They require a pointer to
the COM interface as first argument, in addition to those parameters that
are specified in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> tuple.</p>
</dd></dl>

<p>The optional <em>paramflags</em> parameter creates foreign function wrappers with much
more functionality than the features described above.</p>
<p><em>paramflags</em> must be a tuple of the same length as <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>.</p>
<p>Each item in this tuple contains further information about a parameter, it must
be a tuple containing one, two, or three items.</p>
<p>The first item is an integer containing a combination of direction
flags for the parameter:</p>
<blockquote>
<div><dl class="simple">
<dt>1</dt><dd><p>Specifies an input parameter to the function.</p>
</dd>
<dt>2</dt><dd><p>Output parameter.  The foreign function fills in a value.</p>
</dd>
<dt>4</dt><dd><p>Input parameter which defaults to the integer zero.</p>
</dd>
</dl>
</div></blockquote>
<p>The optional second item is the parameter name as string.  If this is specified,
the foreign function can be called with named parameters.</p>
<p>The optional third item is the default value for this parameter.</p>
</div></blockquote>
<p>This example demonstrates how to wrap the Windows <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> function so
that it supports default parameters and named arguments. The C declaration from
the windows header file is this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p>Here is the wrapping with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> foreign function can now be called in these ways:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>A second example demonstrates output parameters.  The win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code>
function retrieves the dimensions of a specified window by copying them into
<code class="docutils literal notranslate"><span class="pre">RECT</span></code> structure that the caller has to supply.  Here is the C declaration:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p>Here is the wrapping with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Functions with output parameters will automatically return the output parameter
value if there is a single one, or a tuple containing the output parameter
values when there are more than one, so the GetWindowRect function now returns a
RECT instance, when called.</p>
<p>Output parameters can be combined with the <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> protocol to do
further output processing and error checking.  The win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> api
function returns a <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> to signal success or failure, so this function could
do the error checking, and raises an exception when the api call failed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>If the <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> function returns the argument tuple it receives
unchanged, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> continues the normal processing it does on the output
parameters.  If you want to return a tuple of window coordinates instead of a
<code class="docutils literal notranslate"><span class="pre">RECT</span></code> instance, you can retrieve the fields in the function and return them
instead, the normal processing will no longer take place:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="utility-functions">
<span id="ctypes-utility-functions"></span><h3>Utility functions<a class="headerlink" href="#utility-functions" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="ctypes.addressof">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">addressof</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the address of the memory buffer as integer.  <em>obj</em> must be an
instance of a ctypes type.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.alignment">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">alignment</code><span class="sig-paren">(</span><em class="sig-param">obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the alignment requirements of a ctypes type. <em>obj_or_type</em> must be a
ctypes type or instance.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.byref">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">byref</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="optional">[</span>, <em class="sig-param">offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="永久链接至目标">¶</a></dt>
<dd><p>Returns a light-weight pointer to <em>obj</em>, which must be an instance of a
ctypes type.  <em>offset</em> defaults to zero, and must be an integer that will be
added to the internal pointer value.</p>
<p><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> corresponds to this C code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned object can only be used as a foreign function call parameter.
It behaves similar to <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>, but the construction is a lot faster.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.cast">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="永久链接至目标">¶</a></dt>
<dd><p>This function is similar to the cast operator in C. It returns a new instance
of <em>type</em> which points to the same memory block as <em>obj</em>.  <em>type</em> must be a
pointer type, and <em>obj</em> must be an object that can be interpreted as a
pointer.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_string_buffer">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">create_string_buffer</code><span class="sig-paren">(</span><em class="sig-param">init_or_size</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>This function creates a mutable character buffer. The returned object is a
ctypes array of <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a>.</p>
<p><em>init_or_size</em> must be an integer which specifies the size of the array, or a
bytes object which will be used to initialize the array items.</p>
<p>If a bytes object is specified as first argument, the buffer is made one item
larger than its length so that the last element in the array is a NUL
termination character. An integer can be passed as second argument which allows
specifying the size of the array if the length of the bytes should not be used.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_unicode_buffer">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">create_unicode_buffer</code><span class="sig-paren">(</span><em class="sig-param">init_or_size</em>, <em class="sig-param">size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>This function creates a mutable unicode character buffer. The returned object is
a ctypes array of <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a>.</p>
<p><em>init_or_size</em> must be an integer which specifies the size of the array, or a
string which will be used to initialize the array items.</p>
<p>If a string is specified as first argument, the buffer is made one item
larger than the length of the string so that the last element in the array is a
NUL termination character. An integer can be passed as second argument which
allows specifying the size of the array if the length of the string should not
be used.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllCanUnloadNow">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">DllCanUnloadNow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: This function is a hook which allows implementing in-process
COM servers with ctypes.  It is called from the DllCanUnloadNow function that
the _ctypes extension dll exports.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllGetClassObject">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">DllGetClassObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: This function is a hook which allows implementing in-process
COM servers with ctypes.  It is called from the DllGetClassObject function
that the <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> extension dll exports.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_library">
<code class="sig-prename descclassname">ctypes.util.</code><code class="sig-name descname">find_library</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="永久链接至目标">¶</a></dt>
<dd><p>Try to find a library and return a pathname.  <em>name</em> is the library name
without any prefix like <code class="docutils literal notranslate"><span class="pre">lib</span></code>, suffix like <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> or version
number (this is the form used for the posix linker option <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>).  If
no library can be found, returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>确切的功能取决于系统。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_msvcrt">
<code class="sig-prename descclassname">ctypes.util.</code><code class="sig-name descname">find_msvcrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: return the filename of the VC runtime library used by Python,
and by the extension modules.  If the name of the library cannot be
determined, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p>If you need to free memory, for example, allocated by an extension module
with a call to the <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code>, it is important that you use the
function in the same library that allocated the memory.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.FormatError">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">FormatError</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">code</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: Returns a textual description of the error code <em>code</em>.  If no
error code is specified, the last error code is used by calling the Windows
api function GetLastError.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.GetLastError">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: Returns the last error code set by Windows in the calling thread.
This function calls the Windows <cite>GetLastError()</cite> function directly,
it does not return the ctypes-private copy of the error code.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_errno">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">get_errno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the current value of the ctypes-private copy of the system
<a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> variable in the calling thread.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_last_error">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">get_last_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: returns the current value of the ctypes-private copy of the system
<code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> variable in the calling thread.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memmove">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">memmove</code><span class="sig-paren">(</span><em class="sig-param">dst</em>, <em class="sig-param">src</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="永久链接至目标">¶</a></dt>
<dd><p>Same as the standard C memmove library function: copies <em>count</em> bytes from
<em>src</em> to <em>dst</em>. <em>dst</em> and <em>src</em> must be integers or ctypes instances that can
be converted to pointers.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memset">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">memset</code><span class="sig-paren">(</span><em class="sig-param">dst</em>, <em class="sig-param">c</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="永久链接至目标">¶</a></dt>
<dd><p>Same as the standard C memset library function: fills the memory block at
address <em>dst</em> with <em>count</em> bytes of value <em>c</em>. <em>dst</em> must be an integer
specifying an address, or a ctypes instance.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.POINTER">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">POINTER</code><span class="sig-paren">(</span><em class="sig-param">type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="永久链接至目标">¶</a></dt>
<dd><p>This factory function creates and returns a new ctypes pointer type. Pointer
types are cached and reused internally, so calling this function repeatedly is
cheap. <em>type</em> must be a ctypes type.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.pointer">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">pointer</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="永久链接至目标">¶</a></dt>
<dd><p>This function creates a new pointer instance, pointing to <em>obj</em>. The returned
object is of the type <code class="docutils literal notranslate"><span class="pre">POINTER(type(obj))</span></code>.</p>
<p>Note: If you just want to pass a pointer to an object to a foreign function
call, you should use <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code> which is much faster.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.resize">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">resize</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="永久链接至目标">¶</a></dt>
<dd><p>This function resizes the internal memory buffer of <em>obj</em>, which must be an
instance of a ctypes type.  It is not possible to make the buffer smaller
than the native size of the objects type, as given by <code class="docutils literal notranslate"><span class="pre">sizeof(type(obj))</span></code>,
but it is possible to enlarge the buffer.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_errno">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">set_errno</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="永久链接至目标">¶</a></dt>
<dd><p>Set the current value of the ctypes-private copy of the system <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a>
variable in the calling thread to <em>value</em> and return the previous value.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_last_error">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">set_last_error</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: set the current value of the ctypes-private copy of the system
<code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> variable in the calling thread to <em>value</em> and return the
previous value.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.sizeof">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">sizeof</code><span class="sig-paren">(</span><em class="sig-param">obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the size in bytes of a ctypes type or instance memory buffer.
Does the same as the C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> operator.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.string_at">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">string_at</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="永久链接至目标">¶</a></dt>
<dd><p>This function returns the C string starting at memory address <em>address</em> as a bytes
object. If size is specified, it is used as size, otherwise the string is assumed
to be zero-terminated.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WinError">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">WinError</code><span class="sig-paren">(</span><em class="sig-param">code=None</em>, <em class="sig-param">descr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: this function is probably the worst-named thing in ctypes. It
creates an instance of OSError.  If <em>code</em> is not specified,
<code class="docutils literal notranslate"><span class="pre">GetLastError</span></code> is called to determine the error code. If <em>descr</em> is not
specified, <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError()</span></code></a> is called to get a textual description of the
error.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>An instance of <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> used to be created.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ctypes.wstring_at">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">wstring_at</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="永久链接至目标">¶</a></dt>
<dd><p>This function returns the wide character string starting at memory address
<em>address</em> as a string.  If <em>size</em> is specified, it is used as the number of
characters of the string, otherwise the string is assumed to be
zero-terminated.</p>
</dd></dl>

</div>
<div class="section" id="data-types">
<span id="ctypes-data-types"></span><h3>Data types<a class="headerlink" href="#data-types" title="永久链接至标题">¶</a></h3>
<dl class="class">
<dt id="ctypes._CData">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_CData</code><a class="headerlink" href="#ctypes._CData" title="永久链接至目标">¶</a></dt>
<dd><p>This non-public class is the common base class of all ctypes data types.
Among other things, all ctypes type instances contain a memory block that
hold C compatible data; the address of the memory block is returned by the
<a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a> helper function. Another instance variable is exposed as
<a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_objects</span></code></a>; this contains other Python objects that need to be kept
alive in case the memory block contains pointers.</p>
<p>Common methods of ctypes data types, these are all class methods (to be
exact, they are methods of the <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>):</p>
<dl class="method">
<dt id="ctypes._CData.from_buffer">
<code class="sig-name descname">from_buffer</code><span class="sig-paren">(</span><em class="sig-param">source</em><span class="optional">[</span>, <em class="sig-param">offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="永久链接至目标">¶</a></dt>
<dd><p>This method returns a ctypes instance that shares the buffer of the
<em>source</em> object.  The <em>source</em> object must support the writeable buffer
interface.  The optional <em>offset</em> parameter specifies an offset into the
source buffer in bytes; the default is zero.  If the source buffer is not
large enough a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_buffer_copy">
<code class="sig-name descname">from_buffer_copy</code><span class="sig-paren">(</span><em class="sig-param">source</em><span class="optional">[</span>, <em class="sig-param">offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="永久链接至目标">¶</a></dt>
<dd><p>This method creates a ctypes instance, copying the buffer from the
<em>source</em> object buffer which must be readable.  The optional <em>offset</em>
parameter specifies an offset into the source buffer in bytes; the default
is zero.  If the source buffer is not large enough a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is
raised.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_address">
<code class="sig-name descname">from_address</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="永久链接至目标">¶</a></dt>
<dd><p>This method returns a ctypes type instance using the memory specified by
<em>address</em> which must be an integer.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_param">
<code class="sig-name descname">from_param</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="永久链接至目标">¶</a></dt>
<dd><p>This method adapts <em>obj</em> to a ctypes type.  It is called with the actual
object used in a foreign function call when the type is present in the
foreign function's <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> tuple; it must return an object that
can be used as a function call parameter.</p>
<p>All ctypes data types have a default implementation of this classmethod
that normally returns <em>obj</em> if that is an instance of the type.  Some
types accept other objects as well.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.in_dll">
<code class="sig-name descname">in_dll</code><span class="sig-paren">(</span><em class="sig-param">library</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="永久链接至目标">¶</a></dt>
<dd><p>This method returns a ctypes type instance exported by a shared
library. <em>name</em> is the name of the symbol that exports the data, <em>library</em>
is the loaded shared library.</p>
</dd></dl>

<p>Common instance variables of ctypes data types:</p>
<dl class="attribute">
<dt id="ctypes._CData._b_base_">
<code class="sig-name descname">_b_base_</code><a class="headerlink" href="#ctypes._CData._b_base_" title="永久链接至目标">¶</a></dt>
<dd><p>Sometimes ctypes data instances do not own the memory block they contain,
instead they share part of the memory block of a base object.  The
<a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> read-only member is the root ctypes object that owns the
memory block.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._b_needsfree_">
<code class="sig-name descname">_b_needsfree_</code><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="永久链接至目标">¶</a></dt>
<dd><p>This read-only variable is true when the ctypes data instance has
allocated the memory block itself, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._objects">
<code class="sig-name descname">_objects</code><a class="headerlink" href="#ctypes._CData._objects" title="永久链接至目标">¶</a></dt>
<dd><p>This member is either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a dictionary containing Python objects
that need to be kept alive so that the memory block contents is kept
valid.  This object is only exposed for debugging; never modify the
contents of this dictionary.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3>基础数据类型<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="永久链接至标题">¶</a></h3>
<dl class="class">
<dt id="ctypes._SimpleCData">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_SimpleCData</code><a class="headerlink" href="#ctypes._SimpleCData" title="永久链接至目标">¶</a></dt>
<dd><p>This non-public class is the base class of all fundamental ctypes data
types. It is mentioned here because it contains the common attributes of the
fundamental ctypes data types.  <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> is a subclass of
<a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a>, so it inherits their methods and attributes. ctypes data
types that are not and do not contain pointers can now be pickled.</p>
<p>Instances have a single attribute:</p>
<dl class="attribute">
<dt id="ctypes._SimpleCData.value">
<code class="sig-name descname">value</code><a class="headerlink" href="#ctypes._SimpleCData.value" title="永久链接至目标">¶</a></dt>
<dd><p>This attribute contains the actual value of the instance. For integer and
pointer types, it is an integer, for character types, it is a single
character bytes object or string, for character pointer types it is a
Python bytes object or string.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute is retrieved from a ctypes instance, usually
a new object is returned each time.  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> does <em>not</em> implement
original object return, always a new object is constructed.  The same is
true for all other ctypes object instances.</p>
</dd></dl>

</dd></dl>

<p>Fundamental data types, when returned as foreign function call results, or, for
example, by retrieving structure field members or array items, are transparently
converted to native Python types.  In other words, if a foreign function has a
<code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> of <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, you will always receive a Python bytes
object, <em>not</em> a <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> instance.</p>
<p>Subclasses of fundamental data types do <em>not</em> inherit this behavior. So, if a
foreign functions <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> is a subclass of <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a>, you will
receive an instance of this subclass from the function call. Of course, you can
get the value of the pointer by accessing the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute.</p>
<p>These are the fundamental ctypes data types:</p>
<dl class="class">
<dt id="ctypes.c_byte">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_byte</code><a class="headerlink" href="#ctypes.c_byte" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code> datatype, and interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_char</code><a class="headerlink" href="#ctypes.c_char" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> datatype, and interprets the value as a single
character.  The constructor accepts an optional string initializer, the
length of the string must be exactly one character.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char_p">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_char_p</code><a class="headerlink" href="#ctypes.c_char_p" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> datatype when it points to a zero-terminated
string.  For a general character pointer that may also point to binary data,
<code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code> must be used.  The constructor accepts an integer
address, or a bytes object.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_double">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_double</code><a class="headerlink" href="#ctypes.c_double" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longdouble">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_longdouble</code><a class="headerlink" href="#ctypes.c_longdouble" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.  On platforms where <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span>
<span class="pre">sizeof(double)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_float">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_float</code><a class="headerlink" href="#ctypes.c_float" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int</code><a class="headerlink" href="#ctypes.c_int" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int8">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int8</code><a class="headerlink" href="#ctypes.c_int8" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int16">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int16</code><a class="headerlink" href="#ctypes.c_int16" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int32">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int32</code><a class="headerlink" href="#ctypes.c_int32" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int64">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int64</code><a class="headerlink" href="#ctypes.c_int64" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_long">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_long</code><a class="headerlink" href="#ctypes.c_long" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longlong">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_longlong</code><a class="headerlink" href="#ctypes.c_longlong" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_short">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_short</code><a class="headerlink" href="#ctypes.c_short" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">short</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_size_t">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_size_t</code><a class="headerlink" href="#ctypes.c_size_t" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code> datatype.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ssize_t">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ssize_t</code><a class="headerlink" href="#ctypes.c_ssize_t" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> datatype.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ubyte">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ubyte</code><a class="headerlink" href="#ctypes.c_ubyte" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> datatype, it interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint</code><a class="headerlink" href="#ctypes.c_uint" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias for <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint8">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint8</code><a class="headerlink" href="#ctypes.c_uint8" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint16">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint16</code><a class="headerlink" href="#ctypes.c_uint16" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint32">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint32</code><a class="headerlink" href="#ctypes.c_uint32" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint64">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint64</code><a class="headerlink" href="#ctypes.c_uint64" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulong">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ulong</code><a class="headerlink" href="#ctypes.c_ulong" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulonglong">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ulonglong</code><a class="headerlink" href="#ctypes.c_ulonglong" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor
accepts an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ushort">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ushort</code><a class="headerlink" href="#ctypes.c_ushort" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_void_p">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_void_p</code><a class="headerlink" href="#ctypes.c_void_p" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> type.  The value is represented as integer.
The constructor accepts an optional integer initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_wchar</code><a class="headerlink" href="#ctypes.c_wchar" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> datatype, and interprets the value as a
single character unicode string.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar_p">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_wchar_p</code><a class="headerlink" href="#ctypes.c_wchar_p" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> datatype, which must be a pointer to a
zero-terminated wide character string.  The constructor accepts an integer
address, or a string.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_bool">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_bool</code><a class="headerlink" href="#ctypes.c_bool" title="永久链接至目标">¶</a></dt>
<dd><p>Represent the C <code class="xref c c-type docutils literal notranslate"><span class="pre">bool</span></code> datatype (more accurately, <code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code> from
C99).  Its value can be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and the constructor accepts any object
that has a truth value.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.HRESULT">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">HRESULT</code><a class="headerlink" href="#ctypes.HRESULT" title="永久链接至目标">¶</a></dt>
<dd><p>Windows only: Represents a <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> value, which contains success or
error information for a function or method call.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.py_object">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">py_object</code><a class="headerlink" href="#ctypes.py_object" title="永久链接至目标">¶</a></dt>
<dd><p>Represents the C <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> datatype.  Calling this without an
argument creates a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> pointer.</p>
</dd></dl>

<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> module provides quite some other Windows specific
data types, for example <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code>, or <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>.  Some
useful structures like <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code> are also defined.</p>
</div>
<div class="section" id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3>Structured data types<a class="headerlink" href="#structured-data-types" title="永久链接至标题">¶</a></h3>
<dl class="class">
<dt id="ctypes.Union">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">Union</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for unions in native byte order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.BigEndianStructure">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">BigEndianStructure</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for structures in <em>big endian</em> byte order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.LittleEndianStructure">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">LittleEndianStructure</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for structures in <em>little endian</em> byte order.</p>
</dd></dl>

<p>Structures with non-native byte order cannot contain pointer type fields, or any
other data types containing pointer type fields.</p>
<dl class="class">
<dt id="ctypes.Structure">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">Structure</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for structures in <em>native</em> byte order.</p>
<p>Concrete structure and union types must be created by subclassing one of these
types, and at least define a <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> will
create <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s which allow reading and writing the fields by direct
attribute accesses.  These are the</p>
<dl class="attribute">
<dt id="ctypes.Structure._fields_">
<code class="sig-name descname">_fields_</code><a class="headerlink" href="#ctypes.Structure._fields_" title="永久链接至目标">¶</a></dt>
<dd><p>A sequence defining the structure fields.  The items must be 2-tuples or
3-tuples.  The first item is the name of the field, the second item
specifies the type of the field; it can be any ctypes data type.</p>
<p>For integer type fields like <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, a third optional item can be
given.  It must be a small positive integer defining the bit width of the
field.</p>
<p>Field names must be unique within one structure or union.  This is not
checked, only one field can be accessed when names are repeated.</p>
<p>It is possible to define the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable <em>after</em> the
class statement that defines the Structure subclass, this allows creating
data types that directly or indirectly reference themselves:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable must, however, be defined before the
type is first used (an instance is created, <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a> is called on it,
and so on).  Later assignments to the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable will
raise an AttributeError.</p>
<p>It is possible to define sub-subclasses of structure types, they inherit
the fields of the base class plus the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> defined in the
sub-subclass, if any.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._pack_">
<code class="sig-name descname">_pack_</code><a class="headerlink" href="#ctypes.Structure._pack_" title="永久链接至目标">¶</a></dt>
<dd><p>An optional small integer that allows overriding the alignment of
structure fields in the instance.  <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> must already be defined
when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is assigned, otherwise it will have no effect.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._anonymous_">
<code class="sig-name descname">_anonymous_</code><a class="headerlink" href="#ctypes.Structure._anonymous_" title="永久链接至目标">¶</a></dt>
<dd><p>An optional sequence that lists the names of unnamed (anonymous) fields.
<a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a> must be already defined when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is
assigned, otherwise it will have no effect.</p>
<p>The fields listed in this variable must be structure or union type fields.
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> will create descriptors in the structure type that allows
accessing the nested fields directly, without the need to create the
structure or union field.</p>
<p>Here is an example type (Windows):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> structure describes a COM data type, the <code class="docutils literal notranslate"><span class="pre">vt</span></code> field
specifies which one of the union fields is valid.  Since the <code class="docutils literal notranslate"><span class="pre">u</span></code> field
is defined as anonymous field, it is now possible to access the members
directly off the TYPEDESC instance. <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> and <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code>
are equivalent, but the former is faster since it does not need to create
a temporary union instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>It is possible to define sub-subclasses of structures, they inherit the
fields of the base class.  If the subclass definition has a separate
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> variable, the fields specified in this are appended to the
fields of the base class.</p>
<p>Structure and union constructors accept both positional and keyword
arguments.  Positional arguments are used to initialize member fields in the
same order as they are appear in <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.  Keyword arguments in the
constructor are interpreted as attribute assignments, so they will initialize
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> with the same name, or create new attributes for names not
present in <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3>Arrays and pointers<a class="headerlink" href="#arrays-and-pointers" title="永久链接至标题">¶</a></h3>
<dl class="class">
<dt id="ctypes.Array">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">Array</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for arrays.</p>
<p>The recommended way to create concrete array types is by multiplying any
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> data type with a positive integer.  Alternatively, you can subclass
this type and define <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> and <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a> class variables.
Array elements can be read and written using standard
subscript and slice accesses; for slice reads, the resulting object is
<em>not</em> itself an <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
<dl class="attribute">
<dt id="ctypes.Array._length_">
<code class="sig-name descname">_length_</code><a class="headerlink" href="#ctypes.Array._length_" title="永久链接至目标">¶</a></dt>
<dd><p>A positive integer specifying the number of elements in the array.
Out-of-range subscripts result in an <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Will be
returned by <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Array._type_">
<code class="sig-name descname">_type_</code><a class="headerlink" href="#ctypes.Array._type_" title="永久链接至目标">¶</a></dt>
<dd><p>Specifies the type of each element in the array.</p>
</dd></dl>

<p>Array subclass constructors accept positional arguments, used to
initialize the elements in order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes._Pointer">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_Pointer</code><a class="headerlink" href="#ctypes._Pointer" title="永久链接至目标">¶</a></dt>
<dd><p>Private, abstract base class for pointers.</p>
<p>Concrete pointer types are created by calling <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> with the
type that will be pointed to; this is done automatically by
<a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>.</p>
<p>If a pointer points to an array, its elements can be read and
written using standard subscript and slice accesses.  Pointer objects
have no size, so <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> will raise <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  Negative
subscripts will read from the memory <em>before</em> the pointer (as in C), and
out-of-range subscripts will probably crash with an access violation (if
you're lucky).</p>
<dl class="attribute">
<dt id="ctypes._Pointer._type_">
<code class="sig-name descname">_type_</code><a class="headerlink" href="#ctypes._Pointer._type_" title="永久链接至目标">¶</a></dt>
<dd><p>Specifies the type pointed to.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._Pointer.contents">
<code class="sig-name descname">contents</code><a class="headerlink" href="#ctypes._Pointer.contents" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the object to which to pointer points.  Assigning to this
attribute changes the pointer to point to the assigned object.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 教程</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">载入动态连接库</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">操作导入的动态链接库中的函数</a></li>
<li><a class="reference internal" href="#calling-functions">调用函数</a></li>
<li><a class="reference internal" href="#fundamental-data-types">基础数据类型</a></li>
<li><a class="reference internal" href="#calling-functions-continued">调用函数，继续</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">使用自定义的数据类型调用函数</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">指定必选参数的类型(函数原型)</a></li>
<li><a class="reference internal" href="#return-types">返回类型</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">传递指针(或者传递引用)</a></li>
<li><a class="reference internal" href="#structures-and-unions">结构体和联合</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">结构体/联合 字段对齐及字节顺序</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">结构体和联合中的位域</a></li>
<li><a class="reference internal" href="#arrays">数组</a></li>
<li><a class="reference internal" href="#pointers">指针</a></li>
<li><a class="reference internal" href="#type-conversions">类型强制转换</a></li>
<li><a class="reference internal" href="#incomplete-types">不完整类型</a></li>
<li><a class="reference internal" href="#callback-functions">回调函数</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">访问 dll 中导出的值</a></li>
<li><a class="reference internal" href="#surprises">意外</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">变长数据类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes 参考手册</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">寻找动态链接库</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">加载动态链接库</a></li>
<li><a class="reference internal" href="#foreign-functions">外部函数</a></li>
<li><a class="reference internal" href="#function-prototypes">函数原型</a></li>
<li><a class="reference internal" href="#utility-functions">Utility functions</a></li>
<li><a class="reference internal" href="#data-types">Data types</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">基础数据类型</a></li>
<li><a class="reference internal" href="#structured-data-types">Structured data types</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arrays and pointers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="errno.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> --- 标准 errno 系统符号</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="concurrency.html"
                        title="下一章">并发执行</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.7/Doc/library/ctypes.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="并发执行"
             >下一页</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- 标准 errno 系统符号"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.7.9 Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >通用操作系统服务</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2020, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    最后更新于 10月 07, 2020.
    <a href="../bugs.html">发现了问题</a>？
    <br />
    使用<a href="http://sphinx.pocoo.org/">Sphinx</a>2.3.1 创建。
    </div>

  </body>
</html>